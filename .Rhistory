a<- 2
b<-3
c<- a+b
demo()
getwd()
setwd("C:\Users\Julian\Desktop\Diplomatura en Ciencia de datos")
> setwd("C:/Users/Julian/Desktop)
#Un vector es un objeto que tiene muchas posiciones, una al lado de la otra,todas del mismo tipo.
v <- numeric(10)
v
w<- c(1,2,3,4,5,6,7,8,9,10)
str(v)
u<- v+w
#Cuando hago la suma entre dos vectores = otro vector sumado componente por componente.
u <- v+1
u
#Cuando a un vector le sumo una constante la suma componente por componente
u <- u*
u<- u*2}
u<-u*2
#Cuando hago una operacion num * vector, la hace componente por componente.
a<-c(1,2,3,4,5)
u+a
#El vector corto lo repite.
a<-c(1,2,3)
u+a
#Lo hace, pero te avisa. El warning me lo muestra y sigue adelante, el error frena.
b<- c(4,5)
d<-c(a,b)
#Alli pudimos concatenar dos vectores, une uno al lado del otro.
#Los vectores pueden ser de tipo caracter.
a<- character(5)
a<- c("a","x", "y")
#Para que me muestre un valor dentro del vector:
a[2]
#En R los vectores se numeran desde 1
#TODOS LOS ELEMENTOS DEL VECTOR TIENEN QUE SER DEL MISMO TIPO.
#Matrices -> Valores en un plano
m <- matrix(nrow=3, ncol=2)
View(m)
m[1,1] <-5
m[,2] <-3
m[3,1] <- 1
m[3,] <-1
2*m
#Si multiplico dos matrices.
a<- matrix(nrow=2,ncol=2)
View(m)
View(a)
a[,]<-1
b<-matrix(nrow=2, ncol=2)
b[1,1] <-1
b[2,2]<- 2
b[1,2]<- 0
b[2,2]<-1
View(m)
View(b)
b[2,1]<-0
a*n
a*b
#Lo que hace es multiplicar posicion por posicion. Lo mismo que hacia con los vectores.
#Las matrices, al igual que los vectores, deben ser homogeneos en tipo.Caracter o numerico.
demo()
w<- c(1,2,3,4,5,6,7,8,9,10)
w+1
a<- character(5)
m <- matrix(nrow=3, ncol=3)
miLista <- list(1,"a",3.5,TRUE)
View(a)
a <- "mi mamá me ama"
b <- replace(a,"á","a")
b
b <- replace(a,"a","á")
b
fecha <- Sys.Date()
fecha + z
a
a <- 2
a
2 <- a
object.size(a)
a <- c("aaaaaaaaaa", "bbbbb")
object.size(a)
b <- c(a,a)
b
a <- c("aaaaaaaaaa", "bbbbb")
object.size(a)
b <- c(a,a)
b
d <- as.factor(b)
levels(d)
b
d <- as.factor(b)
levels(d)
str(d)
levels(d)
levels(d)[2] <- "ccccc"
levels(d)
levels(d)[2] <- "ccccc"
d
t1 <-proc.time()
levels(d)
t2 <-proc.time
t2-t1
t1 <-proc.time()
levels(d)
t2 <-proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){b[which(b=="bbbbbb")]<- "cccccc"}
t2 <- proc.time()
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){b[which(b=="bbbbbb")]<- "cccccc"}
t2 <- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccccccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccccccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
b<- c("aaaaaaaa", "bbbbbb")
for(i in 1:10) {b<-c(b,b)}
object.size(b)
d <- as.factor(b)
object.size(d)
t1 <- proc.time()
for(i in 1:1000){levels(d)[2]<- "cccccc"}
t2<- proc.time()
t2-t1
x
x <-runif(100)
x
x
table(d)
d
table(d)
install.packages(Rhea)
getwd()
packages <-c("ade4","GUniFrac","phangorn","cluster",
"fpc","compare","plotrix","PerformanceAnalytics","reshape","ggplot2","gridExtra","grid","ggrepel",
"gtable","Matrix","cowplot", "Hmisc","corrplot","clusterSim","PMCMRplus")
packages <-c("ade4","GUniFrac","phangorn","cluster",
"fpc","compare","plotrix","PerformanceAnalytics","reshape","ggplot2","gridExtra","grid","ggrepel",
"gtable","Matrix","cowplot", "Hmisc","corrplot","clusterSim","PMCMRplus")
InsPack <- function(pack)
{
if ((pack %in% installed.packages()) == FALSE) {
install.packages(pack,repos = "http://cloud.r-project.org/")
InsPack <- function(ade4)
InsPack <- function(ade4)
View(a)
View(b)
a<-c("julian")
b<-c("Dietrich")
d<-c(a,b)
d
getwd()
#Para saber donde estoy
# Para cambiar directorio --> setwd("Pegar directorio con /")
a <- 1
d <- "mama"
d
str(d)
f <- TRUE
str(f)
v <- numeric(10)
v
w <- c(1,2,3,4,5,6,7,8,9,10)
w
str(v)
str(w)
u <- v+w
u
u <- v+1
u
u <- u*2
u
#OPERACION ENTRE NUMERO Y VECTOR : LO HACE COMPONENTE POR COMPONENTE
a<- c(1,2,3,4,5)
a
u+a
#ACA TIENEN LONGITUDES DISTINTAS, NO DIO ERROR.
#REPITE EL VECTOR A
#CUANDO UN VECTOR QUEDA CORTO, LO REPITE
a <- c(1,2,3)
u+a
#CUANDO UN VECTOR NO ES MULTIPLO DE OTRO, TE DA UN WARNING PERO NO UN ERROR.
B
b<- c(4,5)
d<-c(a,b)
d
#PUEDO CONCATENAR VECTORES
a<- character(5)
a
a<- c("a","x","y")
a
a[2]
#Se numeran desde 1
#VECTORES TIENEN QUE SER HOMOGENEOS (TODAS LAS CAJAS DEL MISMO TIPO)
m <- matrix(nrow=3, ncol=2)
m
m[1,1] <- 5
m
m[,2] <- 3
m
m[3,] <-1
m
2*m
#MULTIPLICA POSICION POR POSICION.
a <- matrix(nrow=2, ncol=2)
a
a[,] <- 1
a
b <- matrix[nrow=2,ncol=2]
b <- matrix(nrow=2,ncol=2)
b[1,1] <-1
b[2,2] <- 2
b[1,2]<- 0
b[2,1]<- 0{}
b[2,1]<- 0
b[2,2]<-1
b
a*b
#MULTIPLICA POSICION POR POSICION, AL IGUAL QUE VECTORES
#vectores y matrices ---> todos los elementos del mismo tipo
#LISTA --> PUEDO MEZCLAR ELEMENTOS
miLista <- list(1,"a",3,2.5,TRUE)
miLista
#La lista puede ser heterogenea.
#Dataframe: conjunto de vectores (que corresponden a columnas)
df <- as.data.frame(a)
df
colnames(df)
rawnames(df)
rownames(df)
rownames(df) <- c("A","B")
colnames(df)<-c("X","Y")
df
z<-c("SI","NO")
str(df)
df<-cbind(df,z)
df
cbind() --> Pegado por columnas
df<-rbind(df,df)
df
write.csv(df,"MiPrueba.csv")
getwd()
h <-read.csv("MiPrueba.csv")
h
h$z
h$X.1<-NULL
H
h
nrow(h)
ncol(h)
head(h)
tail(h)
a<-"abcdefg"
substring(a,3,5)
b<- paste(a,a)
b
b<- paste(a,a,sep="$")
b
b<- paste(a,a, sep="")
b
a<-"mi mama me ama"
b<- replace(a,"a","á")
b
? replace
b <-gsub("a","á",a)
b
a<-c("a","b","c")
replace(a,2,"z")
a
replace(a,c(1,3),"tuvieja")
match(a,"b")
a<-c(a,a)
a
match(a,"b")
pmatch(a,"b")
fecha<- Sys.date()
library(lubridate)
a<-"1"
a
as.interger(a)
as,numeric(a)
as.numerica(a)
as.numeric(a)
a<- c("aaaaaaaaaaaaaa","bbbbbbbbb")
object.size(a)
b<-c(a,a)
object.size(b)
b<-c(b,b)
object.size(b)
t1<-proc.time()
t2<-proc.time()
t2-t1
setwd("C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer"")
setwd(C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer)
setwd("C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer")
file_path <- C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
filepath <- C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
filepath <- "C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
data <- read.csv(file_path)
file_path <- "C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
data <- read.csv(file_path)
file_path <- "C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
data <- read.csv(file_path)
print(data)
file_path <- "C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
data <- read.csv(file_path)
print(data)
df <- subset(data, select = -c(id, X))
View(df)
View(df)
#Categorical target value to numerical
df$diagnosis <- ifelse(df$diagnosis == "M", 1, 0)
View(df)
?sample
#Partition in train and test
set.seed(3)
selection <- sample(x=1:nrow(data),nrow(data)*.7, replace=F )
training <- data[selection,]
testing <- data[-selection,]
#Partition in train and test
set.seed(3)
selection <- sample(x=1:nrow(df),nrow(df)*.7, replace=F )
training <- data[selection,]
testing <- data[-selection,]
arbolRF2 <- randomForest(diagnosis~., #todas las variables menos churn
data=training,
ntree=100, matry=10,
#maxnodes=20,
nodesize = c(30,30)
)
library(randomForest)
arbolRF2 <- randomForest(diagnosis~., #todas las variables menos churn
data=training,
ntree=100, matry=10,
#maxnodes=20,
nodesize = c(30,30)
)
#Partition in train and test
set.seed(3)
selection <- sample(x=1:nrow(df),nrow(df)*.7, replace=F )
training <- df[selection,]
testing <- df[-selection,]
library(randomForest)
arbolRF2 <- randomForest(diagnosis~., #todas las variables menos churn
data=training,
ntree=100, matry=10,
#maxnodes=20,
nodesize = c(30,30)
)
library(randomForest)
arbolRF <- randomForest(diagnosis~., #todas las variables menos churn
data=training,
ntree=100, matry=10,
#maxnodes=20,
nodesize = c(30,30)
)
predTr<-predict(arbolRF, training) #Como predice cada caso en el training, lo mismo que arriba
table(predTr,training$churn) #Matriz de confusion
predTr<-predict(arbolRF, training) #Como predice cada caso en el training, lo mismo que arriba
table(predTr,training$diagnosis) #Matriz de confusion
{r}
objetos2 <- predict(object=arbolRF,nodes=TRUE,
newdata = testing, predict.all=TRUE)
individuales2 <- as.data.frame(objetos2$individual)
#Nos da el score de cada arbol. Cuanto mas cerca de uno, mas chance que se fuge.
agregados2 <- as.data.frame(objetos2$aggregate)
#Nos da la media de todas las votaciones.
View(agregados2)
View(individuales2)
setwd("C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer")
file_path <- "C:/Users/Julian/Desktop/DATA/Proyectos DS/BreastCancer/data.csv"
data <- read.csv(file_path)
print(data)
#Eliminate not usefull variables
df <- subset(data, select = -c(id, X))
#Categorical target value to numerical
df$diagnosis <- ifelse(df$diagnosis == "M", 1, 0)
#Malignous = 1
#Benignous = 0
#Partition in train and test
set.seed(3)
selection <- sample(x=1:nrow(df),nrow(df)*.7, replace=F )
training <- df[selection,]
testing <- df[-selection,]
library(randomForest)
arbolRF <- randomForest(diagnosis~., #todas las variables menos churn
data=training,
ntree=100, matry=10,
#maxnodes=20,
nodesize = c(30,30)
)
objetos2 <- predict(object=arbolRF,nodes=TRUE,
newdata = testing, predict.all=TRUE)
individuales2 <- as.data.frame(objetos2$individual)
#Nos da el score de cada arbol. Cuanto mas cerca de uno, mas chance que se fuge.
agregados2 <- as.data.frame(objetos2$aggregate)
#Nos da la media de todas las votaciones.
View(agregados2)
View(individuales2)
View(df)
